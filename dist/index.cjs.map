{"version":3,"sources":["../src/index.ts","../src/core/types.ts","../src/splitters/TextSplitter.ts","../src/stores/InMemoryStore.ts","../src/embeddings/OpenAIEmbeddings.ts","../src/stores/PostgresStore.ts"],"sourcesContent":["export * from './core/interfaces';\nexport * from './core/types';\nexport { TextSplitter } from './splitters/TextSplitter';\nexport { InMemoryStore } from './stores/InMemoryStore';\nexport { OpenAIEmbeddings } from './embeddings/OpenAIEmbeddings';\nexport { PostgresStore } from './stores/PostgresStore';\nexport type { PostgresStoreOptions } from './stores/PostgresStore';\n","export type SimilarityMetric = 'cosine' | 'euclidean';\n\nexport function cosineSimilarity(a: number[], b: number[]): number {\n  if (a.length !== b.length) throw new Error('Vectors must be same length');\n  let dot = 0;\n  let na = 0;\n  let nb = 0;\n  for (let i = 0; i < a.length; i++) {\n    dot += a[i] * b[i];\n    na += a[i] * a[i];\n    nb += b[i] * b[i];\n  }\n  if (na === 0 || nb === 0) return 0;\n  return dot / (Math.sqrt(na) * Math.sqrt(nb));\n}\n\nexport function euclideanDistance(a: number[], b: number[]): number {\n  if (a.length !== b.length) throw new Error('Vectors must be same length');\n  let s = 0;\n  for (let i = 0; i < a.length; i++) {\n    const d = a[i] - b[i];\n    s += d * d;\n  }\n  return Math.sqrt(s);\n}\n","import { Document } from '../core/interfaces';\n\nexport class TextSplitter {\n  constructor(public chunkSize = 1000, public chunkOverlap = 200) {\n    if (chunkOverlap >= chunkSize) throw new Error('chunkOverlap must be smaller than chunkSize');\n  }\n\n  /** Split a single text into chunked pieces (string array). */\n  splitText(text: string): string[] {\n    // First, naive sentence split to avoid cutting sentences when possible.\n    const sentences = text\n      .replace(/\\r\\n/g, '\\n')\n      .split(/(?<=[.?!])\\s+|\\n+/)\n      .map(s => s.trim())\n      .filter(Boolean);\n\n    const chunks: string[] = [];\n    let current = '';\n\n    for (const sent of sentences) {\n      if (current.length + sent.length + 1 <= this.chunkSize) {\n        current = current ? `${current} ${sent}` : sent;\n      } else {\n        if (current) chunks.push(current);\n        // If single sentence is larger than chunk, break it\n        if (sent.length > this.chunkSize) {\n          for (let i = 0; i < sent.length; i += this.chunkSize - this.chunkOverlap) {\n            chunks.push(sent.slice(i, i + this.chunkSize));\n          }\n          current = '';\n        } else {\n          current = sent;\n        }\n      }\n    }\n    if (current) chunks.push(current);\n\n    // Add overlap: create sliding-window style chunks to ensure overlap between neighbors\n    if (this.chunkOverlap > 0) {\n      const overlapped: string[] = [];\n      for (let i = 0; i < chunks.length; i++) {\n        const base = chunks[i];\n        let composed = base;\n        if (i > 0) {\n          const prev = chunks[i - 1];\n          const keep = Math.min(this.chunkOverlap, prev.length);\n          composed = prev.slice(prev.length - keep) + ' ' + base;\n        }\n        overlapped.push(composed);\n      }\n      return overlapped;\n    }\n\n    return chunks;\n  }\n\n  /** Convenience: split into Document objects (auto id generation optional). */\n  splitToDocuments(text: string, baseId?: string): Document[] {\n    const parts = this.splitText(text);\n    return parts.map((p, i) => ({ id: baseId ? `${baseId}::${i}` : undefined, content: p }));\n  }\n}\n\nexport default TextSplitter;\n","import { Document, VectorStore } from '../core/interfaces';\nimport { cosineSimilarity } from '../core/types';\n\ntype Entry = { id: string; embedding: number[]; doc: Document };\n\nexport class InMemoryStore implements VectorStore {\n  private store = new Map<string, Entry>();\n\n  constructor() {}\n\n  async add(documents: Document[], embeddings: number[][]): Promise<void> {\n    if (documents.length !== embeddings.length) throw new Error('documents and embeddings length mismatch');\n    for (let i = 0; i < documents.length; i++) {\n      const doc = documents[i];\n      const emb = embeddings[i];\n      const id = doc.id ?? this._generateId();\n      this.store.set(id, { id, embedding: emb, doc: { ...doc, id } });\n    }\n  }\n\n  async search(queryEmbedding: number[], topK: number): Promise<Array<{ document: Document; score: number }>> {\n    const results: Array<{ document: Document; score: number }> = [];\n    for (const e of this.store.values()) {\n      try {\n        const score = cosineSimilarity(queryEmbedding, e.embedding);\n        results.push({ document: e.doc, score });\n      } catch (err) {\n        // skip size-mismatch entries\n      }\n    }\n    results.sort((a, b) => b.score - a.score);\n    return results.slice(0, topK);\n  }\n\n  async delete(ids: string[]): Promise<void> {\n    for (const id of ids) this.store.delete(id);\n  }\n\n  async serialize(): Promise<string> {\n    const arr = Array.from(this.store.values()).map(e => ({ id: e.id, embedding: e.embedding, doc: e.doc }));\n    return JSON.stringify(arr);\n  }\n\n  async deserialize(serialized: string): Promise<void> {\n    const arr: Array<{ id: string; embedding: number[]; doc: Document }> = JSON.parse(serialized);\n    this.store.clear();\n    for (const e of arr) this.store.set(e.id, { id: e.id, embedding: e.embedding, doc: e.doc });\n  }\n\n  private _generateId(): string {\n    return Math.random().toString(36).slice(2, 10);\n  }\n}\n\nexport default InMemoryStore;\n","import OpenAI from 'openai';\nimport { Embeddings } from '../core/interfaces';\n\nexport interface OpenAIEmbeddingsOptions {\n  model?: string;\n  apiKey?: string; // optional: falls back to process.env.OPENAI_API_KEY\n}\n\nexport class OpenAIEmbeddings implements Embeddings {\n  private client: OpenAI;\n  readonly model: string;\n  dimension?: number;\n\n  constructor(options: OpenAIEmbeddingsOptions = {}) {\n    this.model = options.model ?? 'text-embedding-3-small';\n    const apiKey = options.apiKey ?? process.env.OPENAI_API_KEY;\n    if (!apiKey) throw new Error('OpenAI API key is required; pass via options or set OPENAI_API_KEY');\n    this.client = new OpenAI({ apiKey });\n  }\n\n  async embed(input: string): Promise<number[]> {\n    const res = await this.client.embeddings.create({ model: this.model, input });\n    const embedding = res.data[0].embedding as number[];\n    this.dimension = embedding.length;\n    return embedding;\n  }\n\n  async embedBatch(inputs: string[]): Promise<number[][]> {\n    const res = await this.client.embeddings.create({ model: this.model, input: inputs });\n    const embeddings = res.data.map((d: any) => d.embedding as number[]);\n    if (embeddings.length > 0) this.dimension = embeddings[0].length;\n    return embeddings;\n  }\n}\n\nexport default OpenAIEmbeddings;\n","import { Pool } from 'pg';\nimport { Document, VectorStore } from '../core/interfaces';\n\nexport interface PostgresStoreOptions {\n  connectionString?: string;\n  pool?: Pool;\n  tableName?: string;\n  embeddingDimension?: number; // optional, used when creating table\n  createTable?: boolean; // whether to attempt to create table and extension\n}\n\nexport class PostgresStore implements VectorStore {\n  private pool: Pool;\n  private table: string;\n  private _ready: Promise<void> | null = null;\n  // Note: we avoid depending on pgvector runtime helpers here and pass vectors as casted params\n\n  constructor(opts: PostgresStoreOptions) {\n    if (opts.pool) this.pool = opts.pool;\n    else if (opts.connectionString) this.pool = new Pool({ connectionString: opts.connectionString });\n    else throw new Error('Either pool or connectionString must be provided');\n\n    this.table = opts.tableName ?? 'documents';\n    // If requested, start initialization to create extension/table. We keep the\n    // promise so public methods can wait for readiness to avoid race\n    // conditions (constructors can't be async).\n    if (opts.createTable) {\n      const dim = opts.embeddingDimension ?? 1536;\n      // capture references to avoid using `this` inside the async initializer\n      const poolRef = this.pool;\n      const tableRef = this.table;\n      this._ready = (async () => {\n        // best-effort: create extension and table; ignore errors but surface later ops' errors\n        try {\n          await poolRef.query(`CREATE EXTENSION IF NOT EXISTS vector;`);\n        } catch (e) {\n          // ignore - extension might already exist or user lacks privileges\n        }\n        try {\n          await poolRef.query(\n            `CREATE TABLE IF NOT EXISTS ${tableRef} (\n              id TEXT PRIMARY KEY,\n              content TEXT,\n              metadata JSONB,\n              embedding vector(${dim})\n            );`\n          );\n        } catch (e) {\n          // ignore table creation errors here; operations will surface errors when attempted\n        }\n      })();\n    } else {\n      this._ready = Promise.resolve();\n    }\n  }\n\n  async add(documents: Document[], embeddings: number[][]): Promise<void> {\n    // Wait for any background initialization (table creation) to complete.\n    if (this._ready) await this._ready;\n    if (documents.length !== embeddings.length) throw new Error('documents and embeddings length mismatch');\n    if (documents.length === 0) return;\n\n    // Build batch upsert query\n    const cols = ['id', 'content', 'metadata', 'embedding'];\n    const valuesSql: string[] = [];\n    const params: any[] = [];\n    let pIdx = 1;\n\n    for (let i = 0; i < documents.length; i++) {\n      const d = documents[i];\n      const id = d.id ?? Math.random().toString(36).slice(2, 10);\n      const content = d.content;\n      const metadata = d.metadata ? d.metadata : null;\n      const emb = embeddings[i];\n      // pass embedding as a vector literal string and cast to vector in the query\n      const embStr = '[' + emb.join(',') + ']';\n      params.push(id, content, metadata, embStr);\n      valuesSql.push(`($${pIdx++}, $${pIdx++}, $${pIdx++}, $${pIdx++}::vector)`);\n    }\n\n    const query = `INSERT INTO ${this.table} (${cols.join(',')}) VALUES ${valuesSql.join(',')} ` +\n      `ON CONFLICT (id) DO UPDATE SET content = EXCLUDED.content, metadata = EXCLUDED.metadata, embedding = EXCLUDED.embedding;`;\n\n    await this.pool.query(query, params as any[]);\n  }\n\n  async search(queryEmbedding: number[], topK: number): Promise<Array<{ document: Document; score: number }>> {\n    // Wait for initialization if applicable.\n    if (this._ready) await this._ready;\n\n    // Use pgvector cosine distance operator '<=>' and map it back to a similarity\n    // score where higher is better. For identical vectors distance == 0 => score == 1.\n    const embStr = '[' + queryEmbedding.join(',') + ']';\n    const q = `SELECT id, content, metadata, embedding <=> $1::vector AS distance FROM ${this.table} ORDER BY embedding <=> $1::vector ASC LIMIT $2;`;\n    const res = await this.pool.query(q, [embStr, topK]);\n    const out: Array<{ document: Document; score: number }> = [];\n    for (const row of res.rows) {\n      const distance = row.distance as number;\n      // Map cosine distance to similarity score. For cosine distance d\n      // similarity = 1 - d. Clamp to reasonable bounds.\n      let score = 1 - distance;\n      if (!Number.isFinite(score)) score = 0;\n      // Optional: clamp between -1 and 1, but we prefer keeping raw similarity.\n      if (score > 1) score = 1;\n      if (score < -1) score = -1;\n      out.push({ document: { id: row.id, content: row.content, metadata: row.metadata }, score });\n    }\n    return out;\n  }\n\n  async delete(ids: string[]): Promise<void> {\n    if (this._ready) await this._ready;\n    if (ids.length === 0) return;\n    await this.pool.query(`DELETE FROM ${this.table} WHERE id = ANY($1)`, [ids]);\n  }\n\n  async serialize(): Promise<string> {\n    if (this._ready) await this._ready;\n    const res = await this.pool.query(`SELECT id, content, metadata, embedding FROM ${this.table}`);\n    // embedding will be returned as array by pgvector's custom parser\n    return JSON.stringify(res.rows);\n  }\n\n  async deserialize(serialized: string): Promise<void> {\n    if (this._ready) await this._ready;\n  const arr: Array<{ id: string; content: string; metadata: any; embedding: number[] }> = JSON.parse(serialized);\n    // simple erase and reinsert (transaction)\n    const client = await this.pool.connect();\n    try {\n      await client.query('BEGIN');\n      await client.query(`TRUNCATE TABLE ${this.table}`);\n      for (const r of arr) {\n        const embStr = '[' + r.embedding.join(',') + ']';\n        await client.query(\n          `INSERT INTO ${this.table} (id, content, metadata, embedding) VALUES ($1, $2, $3, $4::vector)`,\n          [r.id, r.content, r.metadata, embStr]\n        );\n      }\n      await client.query('COMMIT');\n    } catch (e) {\n      await client.query('ROLLBACK');\n      throw e;\n    } finally {\n      client.release();\n    }\n  }\n}\n\nexport default PostgresStore;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACEO,SAAS,iBAAiB,GAAa,GAAqB;AACjE,MAAI,EAAE,WAAW,EAAE;AAAQ,UAAM,IAAI,MAAM,6BAA6B;AACxE,MAAI,MAAM;AACV,MAAI,KAAK;AACT,MAAI,KAAK;AACT,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,WAAO,EAAE,CAAC,IAAI,EAAE,CAAC;AACjB,UAAM,EAAE,CAAC,IAAI,EAAE,CAAC;AAChB,UAAM,EAAE,CAAC,IAAI,EAAE,CAAC;AAAA,EAClB;AACA,MAAI,OAAO,KAAK,OAAO;AAAG,WAAO;AACjC,SAAO,OAAO,KAAK,KAAK,EAAE,IAAI,KAAK,KAAK,EAAE;AAC5C;AAEO,SAAS,kBAAkB,GAAa,GAAqB;AAClE,MAAI,EAAE,WAAW,EAAE;AAAQ,UAAM,IAAI,MAAM,6BAA6B;AACxE,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,UAAM,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;AACpB,SAAK,IAAI;AAAA,EACX;AACA,SAAO,KAAK,KAAK,CAAC;AACpB;;;ACtBO,IAAM,eAAN,MAAmB;AAAA,EACxB,YAAmB,YAAY,KAAa,eAAe,KAAK;AAA7C;AAAyB;AAC1C,QAAI,gBAAgB;AAAW,YAAM,IAAI,MAAM,6CAA6C;AAAA,EAC9F;AAAA;AAAA,EAGA,UAAU,MAAwB;AAEhC,UAAM,YAAY,KACf,QAAQ,SAAS,IAAI,EACrB,MAAM,mBAAmB,EACzB,IAAI,OAAK,EAAE,KAAK,CAAC,EACjB,OAAO,OAAO;AAEjB,UAAM,SAAmB,CAAC;AAC1B,QAAI,UAAU;AAEd,eAAW,QAAQ,WAAW;AAC5B,UAAI,QAAQ,SAAS,KAAK,SAAS,KAAK,KAAK,WAAW;AACtD,kBAAU,UAAU,GAAG,WAAW,SAAS;AAAA,MAC7C,OAAO;AACL,YAAI;AAAS,iBAAO,KAAK,OAAO;AAEhC,YAAI,KAAK,SAAS,KAAK,WAAW;AAChC,mBAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK,KAAK,YAAY,KAAK,cAAc;AACxE,mBAAO,KAAK,KAAK,MAAM,GAAG,IAAI,KAAK,SAAS,CAAC;AAAA,UAC/C;AACA,oBAAU;AAAA,QACZ,OAAO;AACL,oBAAU;AAAA,QACZ;AAAA,MACF;AAAA,IACF;AACA,QAAI;AAAS,aAAO,KAAK,OAAO;AAGhC,QAAI,KAAK,eAAe,GAAG;AACzB,YAAM,aAAuB,CAAC;AAC9B,eAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,cAAM,OAAO,OAAO,CAAC;AACrB,YAAI,WAAW;AACf,YAAI,IAAI,GAAG;AACT,gBAAM,OAAO,OAAO,IAAI,CAAC;AACzB,gBAAM,OAAO,KAAK,IAAI,KAAK,cAAc,KAAK,MAAM;AACpD,qBAAW,KAAK,MAAM,KAAK,SAAS,IAAI,IAAI,MAAM;AAAA,QACpD;AACA,mBAAW,KAAK,QAAQ;AAAA,MAC1B;AACA,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA;AAAA,EAGA,iBAAiB,MAAc,QAA6B;AAC1D,UAAM,QAAQ,KAAK,UAAU,IAAI;AACjC,WAAO,MAAM,IAAI,CAAC,GAAG,OAAO,EAAE,IAAI,SAAS,GAAG,WAAW,MAAM,QAAW,SAAS,EAAE,EAAE;AAAA,EACzF;AACF;;;ACxDO,IAAM,gBAAN,MAA2C;AAAA,EAGhD,cAAc;AAFd,SAAQ,QAAQ,oBAAI,IAAmB;AAAA,EAExB;AAAA,EAEf,MAAM,IAAI,WAAuB,YAAuC;AACtE,QAAI,UAAU,WAAW,WAAW;AAAQ,YAAM,IAAI,MAAM,0CAA0C;AACtG,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,YAAM,MAAM,UAAU,CAAC;AACvB,YAAM,MAAM,WAAW,CAAC;AACxB,YAAM,KAAK,IAAI,MAAM,KAAK,YAAY;AACtC,WAAK,MAAM,IAAI,IAAI,EAAE,IAAI,WAAW,KAAK,KAAK,EAAE,GAAG,KAAK,GAAG,EAAE,CAAC;AAAA,IAChE;AAAA,EACF;AAAA,EAEA,MAAM,OAAO,gBAA0B,MAAqE;AAC1G,UAAM,UAAwD,CAAC;AAC/D,eAAW,KAAK,KAAK,MAAM,OAAO,GAAG;AACnC,UAAI;AACF,cAAM,QAAQ,iBAAiB,gBAAgB,EAAE,SAAS;AAC1D,gBAAQ,KAAK,EAAE,UAAU,EAAE,KAAK,MAAM,CAAC;AAAA,MACzC,SAAS,KAAP;AAAA,MAEF;AAAA,IACF;AACA,YAAQ,KAAK,CAAC,GAAG,MAAM,EAAE,QAAQ,EAAE,KAAK;AACxC,WAAO,QAAQ,MAAM,GAAG,IAAI;AAAA,EAC9B;AAAA,EAEA,MAAM,OAAO,KAA8B;AACzC,eAAW,MAAM;AAAK,WAAK,MAAM,OAAO,EAAE;AAAA,EAC5C;AAAA,EAEA,MAAM,YAA6B;AACjC,UAAM,MAAM,MAAM,KAAK,KAAK,MAAM,OAAO,CAAC,EAAE,IAAI,QAAM,EAAE,IAAI,EAAE,IAAI,WAAW,EAAE,WAAW,KAAK,EAAE,IAAI,EAAE;AACvG,WAAO,KAAK,UAAU,GAAG;AAAA,EAC3B;AAAA,EAEA,MAAM,YAAY,YAAmC;AACnD,UAAM,MAAiE,KAAK,MAAM,UAAU;AAC5F,SAAK,MAAM,MAAM;AACjB,eAAW,KAAK;AAAK,WAAK,MAAM,IAAI,EAAE,IAAI,EAAE,IAAI,EAAE,IAAI,WAAW,EAAE,WAAW,KAAK,EAAE,IAAI,CAAC;AAAA,EAC5F;AAAA,EAEQ,cAAsB;AAC5B,WAAO,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,GAAG,EAAE;AAAA,EAC/C;AACF;;;ACpDA,oBAAmB;AAQZ,IAAM,mBAAN,MAA6C;AAAA,EAKlD,YAAY,UAAmC,CAAC,GAAG;AACjD,SAAK,QAAQ,QAAQ,SAAS;AAC9B,UAAM,SAAS,QAAQ,UAAU,QAAQ,IAAI;AAC7C,QAAI,CAAC;AAAQ,YAAM,IAAI,MAAM,oEAAoE;AACjG,SAAK,SAAS,IAAI,cAAAA,QAAO,EAAE,OAAO,CAAC;AAAA,EACrC;AAAA,EAEA,MAAM,MAAM,OAAkC;AAC5C,UAAM,MAAM,MAAM,KAAK,OAAO,WAAW,OAAO,EAAE,OAAO,KAAK,OAAO,MAAM,CAAC;AAC5E,UAAM,YAAY,IAAI,KAAK,CAAC,EAAE;AAC9B,SAAK,YAAY,UAAU;AAC3B,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,WAAW,QAAuC;AACtD,UAAM,MAAM,MAAM,KAAK,OAAO,WAAW,OAAO,EAAE,OAAO,KAAK,OAAO,OAAO,OAAO,CAAC;AACpF,UAAM,aAAa,IAAI,KAAK,IAAI,CAAC,MAAW,EAAE,SAAqB;AACnE,QAAI,WAAW,SAAS;AAAG,WAAK,YAAY,WAAW,CAAC,EAAE;AAC1D,WAAO;AAAA,EACT;AACF;;;ACjCA,gBAAqB;AAWd,IAAM,gBAAN,MAA2C;AAAA;AAAA,EAMhD,YAAY,MAA4B;AAHxC,SAAQ,SAA+B;AAIrC,QAAI,KAAK;AAAM,WAAK,OAAO,KAAK;AAAA,aACvB,KAAK;AAAkB,WAAK,OAAO,IAAI,eAAK,EAAE,kBAAkB,KAAK,iBAAiB,CAAC;AAAA;AAC3F,YAAM,IAAI,MAAM,kDAAkD;AAEvE,SAAK,QAAQ,KAAK,aAAa;AAI/B,QAAI,KAAK,aAAa;AACpB,YAAM,MAAM,KAAK,sBAAsB;AAEvC,YAAM,UAAU,KAAK;AACrB,YAAM,WAAW,KAAK;AACtB,WAAK,UAAU,YAAY;AAEzB,YAAI;AACF,gBAAM,QAAQ,MAAM,wCAAwC;AAAA,QAC9D,SAAS,GAAP;AAAA,QAEF;AACA,YAAI;AACF,gBAAM,QAAQ;AAAA,YACZ,8BAA8B;AAAA;AAAA;AAAA;AAAA,iCAIT;AAAA;AAAA,UAEvB;AAAA,QACF,SAAS,GAAP;AAAA,QAEF;AAAA,MACF,GAAG;AAAA,IACL,OAAO;AACL,WAAK,SAAS,QAAQ,QAAQ;AAAA,IAChC;AAAA,EACF;AAAA,EAEA,MAAM,IAAI,WAAuB,YAAuC;AAEtE,QAAI,KAAK;AAAQ,YAAM,KAAK;AAC5B,QAAI,UAAU,WAAW,WAAW;AAAQ,YAAM,IAAI,MAAM,0CAA0C;AACtG,QAAI,UAAU,WAAW;AAAG;AAG5B,UAAM,OAAO,CAAC,MAAM,WAAW,YAAY,WAAW;AACtD,UAAM,YAAsB,CAAC;AAC7B,UAAM,SAAgB,CAAC;AACvB,QAAI,OAAO;AAEX,aAAS,IAAI,GAAG,IAAI,UAAU,QAAQ,KAAK;AACzC,YAAM,IAAI,UAAU,CAAC;AACrB,YAAM,KAAK,EAAE,MAAM,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,GAAG,EAAE;AACzD,YAAM,UAAU,EAAE;AAClB,YAAM,WAAW,EAAE,WAAW,EAAE,WAAW;AAC3C,YAAM,MAAM,WAAW,CAAC;AAExB,YAAM,SAAS,MAAM,IAAI,KAAK,GAAG,IAAI;AACrC,aAAO,KAAK,IAAI,SAAS,UAAU,MAAM;AACzC,gBAAU,KAAK,KAAK,YAAY,YAAY,YAAY,iBAAiB;AAAA,IAC3E;AAEA,UAAM,QAAQ,eAAe,KAAK,UAAU,KAAK,KAAK,GAAG,aAAa,UAAU,KAAK,GAAG;AAGxF,UAAM,KAAK,KAAK,MAAM,OAAO,MAAe;AAAA,EAC9C;AAAA,EAEA,MAAM,OAAO,gBAA0B,MAAqE;AAE1G,QAAI,KAAK;AAAQ,YAAM,KAAK;AAI5B,UAAM,SAAS,MAAM,eAAe,KAAK,GAAG,IAAI;AAChD,UAAM,IAAI,2EAA2E,KAAK;AAC1F,UAAM,MAAM,MAAM,KAAK,KAAK,MAAM,GAAG,CAAC,QAAQ,IAAI,CAAC;AACnD,UAAM,MAAoD,CAAC;AAC3D,eAAW,OAAO,IAAI,MAAM;AAC1B,YAAM,WAAW,IAAI;AAGrB,UAAI,QAAQ,IAAI;AAChB,UAAI,CAAC,OAAO,SAAS,KAAK;AAAG,gBAAQ;AAErC,UAAI,QAAQ;AAAG,gBAAQ;AACvB,UAAI,QAAQ;AAAI,gBAAQ;AACxB,UAAI,KAAK,EAAE,UAAU,EAAE,IAAI,IAAI,IAAI,SAAS,IAAI,SAAS,UAAU,IAAI,SAAS,GAAG,MAAM,CAAC;AAAA,IAC5F;AACA,WAAO;AAAA,EACT;AAAA,EAEA,MAAM,OAAO,KAA8B;AACzC,QAAI,KAAK;AAAQ,YAAM,KAAK;AAC5B,QAAI,IAAI,WAAW;AAAG;AACtB,UAAM,KAAK,KAAK,MAAM,eAAe,KAAK,4BAA4B,CAAC,GAAG,CAAC;AAAA,EAC7E;AAAA,EAEA,MAAM,YAA6B;AACjC,QAAI,KAAK;AAAQ,YAAM,KAAK;AAC5B,UAAM,MAAM,MAAM,KAAK,KAAK,MAAM,gDAAgD,KAAK,OAAO;AAE9F,WAAO,KAAK,UAAU,IAAI,IAAI;AAAA,EAChC;AAAA,EAEA,MAAM,YAAY,YAAmC;AACnD,QAAI,KAAK;AAAQ,YAAM,KAAK;AAC9B,UAAM,MAAkF,KAAK,MAAM,UAAU;AAE3G,UAAM,SAAS,MAAM,KAAK,KAAK,QAAQ;AACvC,QAAI;AACF,YAAM,OAAO,MAAM,OAAO;AAC1B,YAAM,OAAO,MAAM,kBAAkB,KAAK,OAAO;AACjD,iBAAW,KAAK,KAAK;AACnB,cAAM,SAAS,MAAM,EAAE,UAAU,KAAK,GAAG,IAAI;AAC7C,cAAM,OAAO;AAAA,UACX,eAAe,KAAK;AAAA,UACpB,CAAC,EAAE,IAAI,EAAE,SAAS,EAAE,UAAU,MAAM;AAAA,QACtC;AAAA,MACF;AACA,YAAM,OAAO,MAAM,QAAQ;AAAA,IAC7B,SAAS,GAAP;AACA,YAAM,OAAO,MAAM,UAAU;AAC7B,YAAM;AAAA,IACR,UAAE;AACA,aAAO,QAAQ;AAAA,IACjB;AAAA,EACF;AACF;","names":["OpenAI"]}